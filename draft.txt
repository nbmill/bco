executor
scheduler


bcontext{}
bcontext.run()

bco::Task<T> some_coroutine(int input)
{
    auto value1 = co_await rpc_a(input);
    auto value2 = co_await rpc_b(value2);
    return co_await rpc_c(value3);
}

{
    //do some stuff
    co_await switch_to(executor);   //how to implement this?
    //do some stuff
}

bco::Task<> bco::socket::read_loop()
{
    while (true)
    {
        auto bytes = co_await socket.read();
        auto obj = codec.decode(byte);
        observer.on_packet(obj);
    }
}


bco::Task<bytes> bco::socket::read()
{
    //this->context->read(this->some_handle);
    struct awaitable
    {
        bool await_ready() const { return false; }
        int await_resume() { return result_; }
        void await_suspend(std::coroutine_handle<> handle)
        {
            socket_->context->read_async(socket_, [handle](){
                handle();
            });
        }
    private:
        bytes result_;
        bco::socket socket_;
    };
}

void bco::Context::read_async(socket, func)
{
    prev_readv(seq);
    set_user_data(seq, info{socket, func});
    io uring summit(this->ring)
}

bco::Context::run()
{
    while (true)
    {
        //......
        io uring peek cqe(&ceq)
        info = get_data(ceq);
        info->callback(); //suspend inside is ok
        //......
        job = job_queue_->pop();
        job();  //suspend inside is ok
        //......
    }
}

void bco::Context::post(func)
{
    this->job_queue_.push(func);
}